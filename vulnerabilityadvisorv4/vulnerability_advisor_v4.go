/**
 * (C) Copyright IBM Corp. 2023.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.72.0-5d70f2bb-20230511-203609
 */

// Package vulnerabilityadvisorv4 : Operations and models for the VulnerabilityAdvisorV4 service
package vulnerabilityadvisorv4

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"time"

	common "github.com/IBM/container-registry-go-sdk/common"
	"github.com/IBM/go-sdk-core/v5/core"
)

// VulnerabilityAdvisorV4 : Management interface of Vulnerability Advisor for IBM Cloud Container Registry
//
// API Version: 4.0.0
type VulnerabilityAdvisorV4 struct {
	Service *core.BaseService

	// The preferred language code for this request.
	AcceptLanguage *string

	// The unique ID for your IBM Cloud account. Run 'ibmcloud cr info' to get the ID of the target account.
	Account *string
}

// DefaultServiceURL is the default URL to make service requests to.
const DefaultServiceURL = "https://icr.io"

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "vulnerability_advisor"

// VulnerabilityAdvisorV4Options : Service options
type VulnerabilityAdvisorV4Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator

	// The preferred language code for this request.
	AcceptLanguage *string 

	// The unique ID for your IBM Cloud account. Run 'ibmcloud cr info' to get the ID of the target account.
	Account *string `validate:"required"`
}

// NewVulnerabilityAdvisorV4UsingExternalConfig : constructs an instance of VulnerabilityAdvisorV4 with passed in options and external configuration.
func NewVulnerabilityAdvisorV4UsingExternalConfig(options *VulnerabilityAdvisorV4Options) (vulnerabilityAdvisor *VulnerabilityAdvisorV4, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	vulnerabilityAdvisor, err = NewVulnerabilityAdvisorV4(options)
	if err != nil {
		return
	}

	err = vulnerabilityAdvisor.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = vulnerabilityAdvisor.Service.SetServiceURL(options.URL)
	}
	return
}

// NewVulnerabilityAdvisorV4 : constructs an instance of VulnerabilityAdvisorV4 with passed in options.
func NewVulnerabilityAdvisorV4(options *VulnerabilityAdvisorV4Options) (service *VulnerabilityAdvisorV4, err error) {
	serviceOptions := &core.ServiceOptions{
		URL:           DefaultServiceURL,
		Authenticator: options.Authenticator,
	}

	err = core.ValidateStruct(options, "options")
	if err != nil {
		return
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &VulnerabilityAdvisorV4{
		Service: baseService,
		AcceptLanguage: options.AcceptLanguage,
		Account: options.Account,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	var endpoints = map[string]string{
		"global": "https://icr.io", // global
		"us-south": "https://us.icr.io", // us-south
		"uk-south": "https://uk.icr.io", // uk-south
		"eu-gb": "https://uk.icr.io", // eu-gb
		"eu-central": "https://de.icr.io", // eu-central
		"eu-de": "https://de.icr.io", // eu-de
		"ap-north": "https://jp.icr.io", // ap-north
		"jp-tok": "https://jp.icr.io", // jp-tok
		"ap-south": "https://au.icr.io", // ap-south
		"au-syd": "https://au.icr.io", // au-syd
		"jp-osa": "https://jp2.icr.io", // jp-osa
		"ca-tor": "https://ca.icr.io", // ca-tor
		"br-sao": "https://br.icr.io", // br-sao
	}

	if url, ok := endpoints[region]; ok {
		return url, nil
	}
	return "", fmt.Errorf("service URL for region '%s' not found", region)
}

// Clone makes a copy of "vulnerabilityAdvisor" suitable for processing requests.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) Clone() *VulnerabilityAdvisorV4 {
	if core.IsNil(vulnerabilityAdvisor) {
		return nil
	}
	clone := *vulnerabilityAdvisor
	clone.Service = vulnerabilityAdvisor.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) SetServiceURL(url string) error {
	return vulnerabilityAdvisor.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) GetServiceURL() string {
	return vulnerabilityAdvisor.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) SetDefaultHeaders(headers http.Header) {
	vulnerabilityAdvisor.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) SetEnableGzipCompression(enableGzip bool) {
	vulnerabilityAdvisor.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) GetEnableGzipCompression() bool {
	return vulnerabilityAdvisor.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	vulnerabilityAdvisor.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) DisableRetries() {
	vulnerabilityAdvisor.Service.DisableRetries()
}

// AccountReportQueryPath : Get the vulnerability assessment for all images
// Get the vulnerability assessment for the list of registry images that belong to a specific account.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) AccountReportQueryPath(accountReportQueryPathOptions *AccountReportQueryPathOptions) (result *ScanReportList, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.AccountReportQueryPathWithContext(context.Background(), accountReportQueryPathOptions)
}

// AccountReportQueryPathWithContext is an alternate form of the AccountReportQueryPath method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) AccountReportQueryPathWithContext(ctx context.Context, accountReportQueryPathOptions *AccountReportQueryPathOptions) (result *ScanReportList, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(accountReportQueryPathOptions, "accountReportQueryPathOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/report/account`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range accountReportQueryPathOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "AccountReportQueryPath")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	if accountReportQueryPathOptions.Repository != nil {
		builder.AddQuery("repository", fmt.Sprint(*accountReportQueryPathOptions.Repository))
	}
	if accountReportQueryPathOptions.IncludeIBM != nil {
		builder.AddQuery("includeIBM", fmt.Sprint(*accountReportQueryPathOptions.IncludeIBM))
	}
	if accountReportQueryPathOptions.IncludePrivate != nil {
		builder.AddQuery("includePrivate", fmt.Sprint(*accountReportQueryPathOptions.IncludePrivate))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalScanReportList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// AccountStatusQueryPath : Get vulnerability assessment status for all images
// Get the vulnerability assessment status for the list of registry images that belong to a specific account.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) AccountStatusQueryPath(accountStatusQueryPathOptions *AccountStatusQueryPathOptions) (result *ScanreportImageSummaryList, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.AccountStatusQueryPathWithContext(context.Background(), accountStatusQueryPathOptions)
}

// AccountStatusQueryPathWithContext is an alternate form of the AccountStatusQueryPath method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) AccountStatusQueryPathWithContext(ctx context.Context, accountStatusQueryPathOptions *AccountStatusQueryPathOptions) (result *ScanreportImageSummaryList, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(accountStatusQueryPathOptions, "accountStatusQueryPathOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/report/account/status`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range accountStatusQueryPathOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "AccountStatusQueryPath")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	if accountStatusQueryPathOptions.Repository != nil {
		builder.AddQuery("repository", fmt.Sprint(*accountStatusQueryPathOptions.Repository))
	}
	if accountStatusQueryPathOptions.IncludeIBM != nil {
		builder.AddQuery("includeIBM", fmt.Sprint(*accountStatusQueryPathOptions.IncludeIBM))
	}
	if accountStatusQueryPathOptions.IncludePrivate != nil {
		builder.AddQuery("includePrivate", fmt.Sprint(*accountStatusQueryPathOptions.IncludePrivate))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalScanreportImageSummaryList)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ImageReportQueryPath : Get vulnerability assessment
// Get the vulnerability assessment for a registry image.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ImageReportQueryPath(imageReportQueryPathOptions *ImageReportQueryPathOptions) (result *ScanReport, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.ImageReportQueryPathWithContext(context.Background(), imageReportQueryPathOptions)
}

// ImageReportQueryPathWithContext is an alternate form of the ImageReportQueryPath method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ImageReportQueryPathWithContext(ctx context.Context, imageReportQueryPathOptions *ImageReportQueryPathOptions) (result *ScanReport, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(imageReportQueryPathOptions, "imageReportQueryPathOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(imageReportQueryPathOptions, "imageReportQueryPathOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"name": *imageReportQueryPathOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/report/image/{name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range imageReportQueryPathOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "ImageReportQueryPath")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalScanReport)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ImageStatusQueryPath : Get vulnerability assessment status
// Get the overall vulnerability status for a registry image.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ImageStatusQueryPath(imageStatusQueryPathOptions *ImageStatusQueryPathOptions) (result *ScanreportSummary, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.ImageStatusQueryPathWithContext(context.Background(), imageStatusQueryPathOptions)
}

// ImageStatusQueryPathWithContext is an alternate form of the ImageStatusQueryPath method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ImageStatusQueryPathWithContext(ctx context.Context, imageStatusQueryPathOptions *ImageStatusQueryPathOptions) (result *ScanreportSummary, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(imageStatusQueryPathOptions, "imageStatusQueryPathOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(imageStatusQueryPathOptions, "imageStatusQueryPathOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"name": *imageStatusQueryPathOptions.Name,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/report/image/status/{name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range imageStatusQueryPathOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "ImageStatusQueryPath")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalScanreportSummary)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListExemptionAccount : List account level exemptions
// List the exemptions that are specified with account level scope.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ListExemptionAccount(listExemptionAccountOptions *ListExemptionAccountOptions) (result []Exemption, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.ListExemptionAccountWithContext(context.Background(), listExemptionAccountOptions)
}

// ListExemptionAccountWithContext is an alternate form of the ListExemptionAccount method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ListExemptionAccountWithContext(ctx context.Context, listExemptionAccountOptions *ListExemptionAccountOptions) (result []Exemption, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listExemptionAccountOptions, "listExemptionAccountOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/exempt/image`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listExemptionAccountOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "ListExemptionAccount")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalExemption)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetExemptionAccount : Get an account level exemption
// Get details of an exemption that is specified with account level scope.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) GetExemptionAccount(getExemptionAccountOptions *GetExemptionAccountOptions) (result *Exemption, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.GetExemptionAccountWithContext(context.Background(), getExemptionAccountOptions)
}

// GetExemptionAccountWithContext is an alternate form of the GetExemptionAccount method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) GetExemptionAccountWithContext(ctx context.Context, getExemptionAccountOptions *GetExemptionAccountOptions) (result *Exemption, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getExemptionAccountOptions, "getExemptionAccountOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getExemptionAccountOptions, "getExemptionAccountOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"issueType": *getExemptionAccountOptions.IssueType,
		"issueID": *getExemptionAccountOptions.IssueID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/exempt/image/issue/{issueType}/{issueID}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getExemptionAccountOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "GetExemptionAccount")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalExemption)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateExemptionAccount : Create or update an account level exemption
// Create or update an exemption that is specified with account level scope.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) CreateExemptionAccount(createExemptionAccountOptions *CreateExemptionAccountOptions) (result *Exemption, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.CreateExemptionAccountWithContext(context.Background(), createExemptionAccountOptions)
}

// CreateExemptionAccountWithContext is an alternate form of the CreateExemptionAccount method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) CreateExemptionAccountWithContext(ctx context.Context, createExemptionAccountOptions *CreateExemptionAccountOptions) (result *Exemption, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createExemptionAccountOptions, "createExemptionAccountOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createExemptionAccountOptions, "createExemptionAccountOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"issueType": *createExemptionAccountOptions.IssueType,
		"issueID": *createExemptionAccountOptions.IssueID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/exempt/image/issue/{issueType}/{issueID}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createExemptionAccountOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "CreateExemptionAccount")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalExemption)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteExemptionAccount : Delete an account level exemption
// Delete an exemption that is specified with account level scope.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) DeleteExemptionAccount(deleteExemptionAccountOptions *DeleteExemptionAccountOptions) (response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.DeleteExemptionAccountWithContext(context.Background(), deleteExemptionAccountOptions)
}

// DeleteExemptionAccountWithContext is an alternate form of the DeleteExemptionAccount method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) DeleteExemptionAccountWithContext(ctx context.Context, deleteExemptionAccountOptions *DeleteExemptionAccountOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteExemptionAccountOptions, "deleteExemptionAccountOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteExemptionAccountOptions, "deleteExemptionAccountOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"issueType": *deleteExemptionAccountOptions.IssueType,
		"issueID": *deleteExemptionAccountOptions.IssueID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/exempt/image/issue/{issueType}/{issueID}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteExemptionAccountOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "DeleteExemptionAccount")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vulnerabilityAdvisor.Service.Request(request, nil)

	return
}

// ListExemptionResource : List resource exemptions
// List the exemptions that are specified for a resource (account, registry namespace, repository, or image).
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ListExemptionResource(listExemptionResourceOptions *ListExemptionResourceOptions) (result []Exemption, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.ListExemptionResourceWithContext(context.Background(), listExemptionResourceOptions)
}

// ListExemptionResourceWithContext is an alternate form of the ListExemptionResource method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ListExemptionResourceWithContext(ctx context.Context, listExemptionResourceOptions *ListExemptionResourceOptions) (result []Exemption, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listExemptionResourceOptions, "listExemptionResourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listExemptionResourceOptions, "listExemptionResourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"resource": *listExemptionResourceOptions.Resource,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/exempt/image/{resource}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listExemptionResourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "ListExemptionResource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalExemption)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// GetExemptionResource : Get details of a resource exemption
// Get an exemption that is specified for a resource (account, registry namespace, repository, or image).
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) GetExemptionResource(getExemptionResourceOptions *GetExemptionResourceOptions) (result *Exemption, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.GetExemptionResourceWithContext(context.Background(), getExemptionResourceOptions)
}

// GetExemptionResourceWithContext is an alternate form of the GetExemptionResource method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) GetExemptionResourceWithContext(ctx context.Context, getExemptionResourceOptions *GetExemptionResourceOptions) (result *Exemption, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(getExemptionResourceOptions, "getExemptionResourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(getExemptionResourceOptions, "getExemptionResourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"resource": *getExemptionResourceOptions.Resource,
		"issueType": *getExemptionResourceOptions.IssueType,
		"issueID": *getExemptionResourceOptions.IssueID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/exempt/image/{resource}/issue/{issueType}/{issueID}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range getExemptionResourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "GetExemptionResource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalExemption)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CreateExemptionResource : Create or update a resource exemption
// Create or update an exemption that is specified for a resource (account, registry namespace, repository, or image).
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) CreateExemptionResource(createExemptionResourceOptions *CreateExemptionResourceOptions) (result *Exemption, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.CreateExemptionResourceWithContext(context.Background(), createExemptionResourceOptions)
}

// CreateExemptionResourceWithContext is an alternate form of the CreateExemptionResource method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) CreateExemptionResourceWithContext(ctx context.Context, createExemptionResourceOptions *CreateExemptionResourceOptions) (result *Exemption, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(createExemptionResourceOptions, "createExemptionResourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(createExemptionResourceOptions, "createExemptionResourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"resource": *createExemptionResourceOptions.Resource,
		"issueType": *createExemptionResourceOptions.IssueType,
		"issueID": *createExemptionResourceOptions.IssueID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/exempt/image/{resource}/issue/{issueType}/{issueID}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range createExemptionResourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "CreateExemptionResource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalExemption)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DeleteExemptionResource : Delete a resource exemption
// Delete an exemption that is specified for a resource (account, registry namespace, repository, or image).
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) DeleteExemptionResource(deleteExemptionResourceOptions *DeleteExemptionResourceOptions) (response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.DeleteExemptionResourceWithContext(context.Background(), deleteExemptionResourceOptions)
}

// DeleteExemptionResourceWithContext is an alternate form of the DeleteExemptionResource method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) DeleteExemptionResourceWithContext(ctx context.Context, deleteExemptionResourceOptions *DeleteExemptionResourceOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(deleteExemptionResourceOptions, "deleteExemptionResourceOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(deleteExemptionResourceOptions, "deleteExemptionResourceOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"resource": *deleteExemptionResourceOptions.Resource,
		"issueType": *deleteExemptionResourceOptions.IssueType,
		"issueID": *deleteExemptionResourceOptions.IssueID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/exempt/image/{resource}/issue/{issueType}/{issueID}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range deleteExemptionResourceOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "DeleteExemptionResource")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = vulnerabilityAdvisor.Service.Request(request, nil)

	return
}

// ExemptHandler : List the types of exemption
// List the types of exemption.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ExemptHandler(exemptHandlerOptions *ExemptHandlerOptions) (result []ExemptionTypeInfo, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.ExemptHandlerWithContext(context.Background(), exemptHandlerOptions)
}

// ExemptHandlerWithContext is an alternate form of the ExemptHandler method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ExemptHandlerWithContext(ctx context.Context, exemptHandlerOptions *ExemptHandlerOptions) (result []ExemptionTypeInfo, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(exemptHandlerOptions, "exemptHandlerOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/exempt/types`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range exemptHandlerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "ExemptHandler")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalExemptionTypeInfo)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListAccountExemptions : List all exemptions
// List all of the exemptions in the given account.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ListAccountExemptions(listAccountExemptionsOptions *ListAccountExemptionsOptions) (result []Exemption, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.ListAccountExemptionsWithContext(context.Background(), listAccountExemptionsOptions)
}

// ListAccountExemptionsWithContext is an alternate form of the ListAccountExemptions method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ListAccountExemptionsWithContext(ctx context.Context, listAccountExemptionsOptions *ListAccountExemptionsOptions) (result []Exemption, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(listAccountExemptionsOptions, "listAccountExemptionsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/exemptions/account`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listAccountExemptionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "ListAccountExemptions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalExemption)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ExemptionsAccountDeleteHandler : Delete all exemptions
// Delete all of the exemptions in the given account.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ExemptionsAccountDeleteHandler(exemptionsAccountDeleteHandlerOptions *ExemptionsAccountDeleteHandlerOptions) (result *ExemptionDeletionInfo, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.ExemptionsAccountDeleteHandlerWithContext(context.Background(), exemptionsAccountDeleteHandlerOptions)
}

// ExemptionsAccountDeleteHandlerWithContext is an alternate form of the ExemptionsAccountDeleteHandler method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ExemptionsAccountDeleteHandlerWithContext(ctx context.Context, exemptionsAccountDeleteHandlerOptions *ExemptionsAccountDeleteHandlerOptions) (result *ExemptionDeletionInfo, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(exemptionsAccountDeleteHandlerOptions, "exemptionsAccountDeleteHandlerOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/exemptions/deleteAll`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range exemptionsAccountDeleteHandlerOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "ExemptionsAccountDeleteHandler")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalExemptionDeletionInfo)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListImageExemptions : List image exemptions
// List all of the exemptions for an image.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ListImageExemptions(listImageExemptionsOptions *ListImageExemptionsOptions) (result []Exemption, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.ListImageExemptionsWithContext(context.Background(), listImageExemptionsOptions)
}

// ListImageExemptionsWithContext is an alternate form of the ListImageExemptions method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ListImageExemptionsWithContext(ctx context.Context, listImageExemptionsOptions *ListImageExemptionsOptions) (result []Exemption, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listImageExemptionsOptions, "listImageExemptionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listImageExemptionsOptions, "listImageExemptionsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"resource": *listImageExemptionsOptions.Resource,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/exemptions/image/{resource}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range listImageExemptionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "ListImageExemptions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	if listImageExemptionsOptions.IncludeScope != nil {
		builder.AddQuery("includeScope", fmt.Sprint(*listImageExemptionsOptions.IncludeScope))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalExemption)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ListBulkImageExemptions : List exemptions for images
// List the exemptions for the given list of images.
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ListBulkImageExemptions(listBulkImageExemptionsOptions *ListBulkImageExemptionsOptions) (result map[string][]Exemption, response *core.DetailedResponse, err error) {
	return vulnerabilityAdvisor.ListBulkImageExemptionsWithContext(context.Background(), listBulkImageExemptionsOptions)
}

// ListBulkImageExemptionsWithContext is an alternate form of the ListBulkImageExemptions method which supports a Context parameter
func (vulnerabilityAdvisor *VulnerabilityAdvisorV4) ListBulkImageExemptionsWithContext(ctx context.Context, listBulkImageExemptionsOptions *ListBulkImageExemptionsOptions) (result map[string][]Exemption, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(listBulkImageExemptionsOptions, "listBulkImageExemptionsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(listBulkImageExemptionsOptions, "listBulkImageExemptionsOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = vulnerabilityAdvisor.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(vulnerabilityAdvisor.Service.Options.URL, `/va/api/v4/exemptions/images`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range listBulkImageExemptionsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("vulnerability_advisor", "V4", "ListBulkImageExemptions")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if vulnerabilityAdvisor.Account != nil {
		builder.AddHeader("Account", fmt.Sprint(*vulnerabilityAdvisor.Account))
	}
	if vulnerabilityAdvisor.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*vulnerabilityAdvisor.AcceptLanguage))
	}

	_, err = builder.SetBodyContentJSON(listBulkImageExemptionsOptions.Body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = vulnerabilityAdvisor.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalExemption)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// AccountReportQueryPathOptions : The AccountReportQueryPath options.
type AccountReportQueryPathOptions struct {
	// The name of the repository that you want to see image vulnerability assessments for. For example,
	// us.icr.io/namespace/image.
	Repository *string `json:"repository,omitempty"`

	// When set to true, the returned list contains IBM public images and the account images. If not set, or set to false,
	// the list contains only the account images.
	IncludeIBM *string `json:"includeIBM,omitempty"`

	// When set to false, the returned list does not contain the private account images. If not set, or set to true, the
	// list contains the private account images.
	IncludePrivate *string `json:"includePrivate,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAccountReportQueryPathOptions : Instantiate AccountReportQueryPathOptions
func (*VulnerabilityAdvisorV4) NewAccountReportQueryPathOptions() *AccountReportQueryPathOptions {
	return &AccountReportQueryPathOptions{}
}

// SetRepository : Allow user to set Repository
func (_options *AccountReportQueryPathOptions) SetRepository(repository string) *AccountReportQueryPathOptions {
	_options.Repository = core.StringPtr(repository)
	return _options
}

// SetIncludeIBM : Allow user to set IncludeIBM
func (_options *AccountReportQueryPathOptions) SetIncludeIBM(includeIBM string) *AccountReportQueryPathOptions {
	_options.IncludeIBM = core.StringPtr(includeIBM)
	return _options
}

// SetIncludePrivate : Allow user to set IncludePrivate
func (_options *AccountReportQueryPathOptions) SetIncludePrivate(includePrivate string) *AccountReportQueryPathOptions {
	_options.IncludePrivate = core.StringPtr(includePrivate)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *AccountReportQueryPathOptions) SetHeaders(param map[string]string) *AccountReportQueryPathOptions {
	options.Headers = param
	return options
}

// AccountStatusQueryPathOptions : The AccountStatusQueryPath options.
type AccountStatusQueryPathOptions struct {
	// The name of the repository that you want to see image vulnerability assessments for. For example,
	// us.icr.io/namespace/image.
	Repository *string `json:"repository,omitempty"`

	// When set to true, the returned list contains IBM public images and the account images. If not set, or set to false,
	// the list contains only the account images.
	IncludeIBM *string `json:"includeIBM,omitempty"`

	// When set to false, the returned list does not contain the private account images. If not set, or set to true, the
	// list contains the private account images.
	IncludePrivate *string `json:"includePrivate,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewAccountStatusQueryPathOptions : Instantiate AccountStatusQueryPathOptions
func (*VulnerabilityAdvisorV4) NewAccountStatusQueryPathOptions() *AccountStatusQueryPathOptions {
	return &AccountStatusQueryPathOptions{}
}

// SetRepository : Allow user to set Repository
func (_options *AccountStatusQueryPathOptions) SetRepository(repository string) *AccountStatusQueryPathOptions {
	_options.Repository = core.StringPtr(repository)
	return _options
}

// SetIncludeIBM : Allow user to set IncludeIBM
func (_options *AccountStatusQueryPathOptions) SetIncludeIBM(includeIBM string) *AccountStatusQueryPathOptions {
	_options.IncludeIBM = core.StringPtr(includeIBM)
	return _options
}

// SetIncludePrivate : Allow user to set IncludePrivate
func (_options *AccountStatusQueryPathOptions) SetIncludePrivate(includePrivate string) *AccountStatusQueryPathOptions {
	_options.IncludePrivate = core.StringPtr(includePrivate)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *AccountStatusQueryPathOptions) SetHeaders(param map[string]string) *AccountStatusQueryPathOptions {
	options.Headers = param
	return options
}

// CreateExemptionAccountOptions : The CreateExemptionAccount options.
type CreateExemptionAccountOptions struct {
	// Exemption type, e.g. 'cve' or 'sn' or 'configuration'. See /va/api/v4/exempt/types for more details.
	IssueType *string `json:"issueType" validate:"required,ne="`

	// Exemption ID, e.g. 'CVE-2018-9999'. See /va/api/v4/exempt/types for more details.
	IssueID *string `json:"issueID" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateExemptionAccountOptions : Instantiate CreateExemptionAccountOptions
func (*VulnerabilityAdvisorV4) NewCreateExemptionAccountOptions(issueType string, issueID string) *CreateExemptionAccountOptions {
	return &CreateExemptionAccountOptions{
		IssueType: core.StringPtr(issueType),
		IssueID: core.StringPtr(issueID),
	}
}

// SetIssueType : Allow user to set IssueType
func (_options *CreateExemptionAccountOptions) SetIssueType(issueType string) *CreateExemptionAccountOptions {
	_options.IssueType = core.StringPtr(issueType)
	return _options
}

// SetIssueID : Allow user to set IssueID
func (_options *CreateExemptionAccountOptions) SetIssueID(issueID string) *CreateExemptionAccountOptions {
	_options.IssueID = core.StringPtr(issueID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateExemptionAccountOptions) SetHeaders(param map[string]string) *CreateExemptionAccountOptions {
	options.Headers = param
	return options
}

// CreateExemptionResourceOptions : The CreateExemptionResource options.
type CreateExemptionResourceOptions struct {
	// IBM Cloud Registry resource (namespace, namespace/repository, namespace/repository:tag, or
	// namespace/repository@sha256:hash).
	Resource *string `json:"resource" validate:"required,ne="`

	// Exemption type, e.g. 'cve' or 'sn' or 'configuration'. See /va/api/v4/exempt/types for more details.
	IssueType *string `json:"issueType" validate:"required,ne="`

	// Exemption ID, e.g. 'CVE-2018-9999'. See /va/api/v4/exempt/types for more details.
	IssueID *string `json:"issueID" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCreateExemptionResourceOptions : Instantiate CreateExemptionResourceOptions
func (*VulnerabilityAdvisorV4) NewCreateExemptionResourceOptions(resource string, issueType string, issueID string) *CreateExemptionResourceOptions {
	return &CreateExemptionResourceOptions{
		Resource: core.StringPtr(resource),
		IssueType: core.StringPtr(issueType),
		IssueID: core.StringPtr(issueID),
	}
}

// SetResource : Allow user to set Resource
func (_options *CreateExemptionResourceOptions) SetResource(resource string) *CreateExemptionResourceOptions {
	_options.Resource = core.StringPtr(resource)
	return _options
}

// SetIssueType : Allow user to set IssueType
func (_options *CreateExemptionResourceOptions) SetIssueType(issueType string) *CreateExemptionResourceOptions {
	_options.IssueType = core.StringPtr(issueType)
	return _options
}

// SetIssueID : Allow user to set IssueID
func (_options *CreateExemptionResourceOptions) SetIssueID(issueID string) *CreateExemptionResourceOptions {
	_options.IssueID = core.StringPtr(issueID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CreateExemptionResourceOptions) SetHeaders(param map[string]string) *CreateExemptionResourceOptions {
	options.Headers = param
	return options
}

// DeleteExemptionAccountOptions : The DeleteExemptionAccount options.
type DeleteExemptionAccountOptions struct {
	// Exemption type, e.g. 'cve' or 'sn' or 'configuration'. See /va/api/v4/exempt/types for more details.
	IssueType *string `json:"issueType" validate:"required,ne="`

	// Exemption ID, e.g. 'CVE-2018-9999'. See /va/api/v4/exempt/types for more details.
	IssueID *string `json:"issueID" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteExemptionAccountOptions : Instantiate DeleteExemptionAccountOptions
func (*VulnerabilityAdvisorV4) NewDeleteExemptionAccountOptions(issueType string, issueID string) *DeleteExemptionAccountOptions {
	return &DeleteExemptionAccountOptions{
		IssueType: core.StringPtr(issueType),
		IssueID: core.StringPtr(issueID),
	}
}

// SetIssueType : Allow user to set IssueType
func (_options *DeleteExemptionAccountOptions) SetIssueType(issueType string) *DeleteExemptionAccountOptions {
	_options.IssueType = core.StringPtr(issueType)
	return _options
}

// SetIssueID : Allow user to set IssueID
func (_options *DeleteExemptionAccountOptions) SetIssueID(issueID string) *DeleteExemptionAccountOptions {
	_options.IssueID = core.StringPtr(issueID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteExemptionAccountOptions) SetHeaders(param map[string]string) *DeleteExemptionAccountOptions {
	options.Headers = param
	return options
}

// DeleteExemptionResourceOptions : The DeleteExemptionResource options.
type DeleteExemptionResourceOptions struct {
	// IBM Cloud Registry resource (namespace, namespace/repository, namespace/repository:tag, or
	// namespace/repository@sha256:hash).
	Resource *string `json:"resource" validate:"required,ne="`

	// Exemption type, e.g. 'cve' or 'sn' or 'configuration'. See /va/api/v4/exempt/types for more details.
	IssueType *string `json:"issueType" validate:"required,ne="`

	// Exemption ID, e.g. 'CVE-2018-9999'. See /va/api/v4/exempt/types for more details.
	IssueID *string `json:"issueID" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewDeleteExemptionResourceOptions : Instantiate DeleteExemptionResourceOptions
func (*VulnerabilityAdvisorV4) NewDeleteExemptionResourceOptions(resource string, issueType string, issueID string) *DeleteExemptionResourceOptions {
	return &DeleteExemptionResourceOptions{
		Resource: core.StringPtr(resource),
		IssueType: core.StringPtr(issueType),
		IssueID: core.StringPtr(issueID),
	}
}

// SetResource : Allow user to set Resource
func (_options *DeleteExemptionResourceOptions) SetResource(resource string) *DeleteExemptionResourceOptions {
	_options.Resource = core.StringPtr(resource)
	return _options
}

// SetIssueType : Allow user to set IssueType
func (_options *DeleteExemptionResourceOptions) SetIssueType(issueType string) *DeleteExemptionResourceOptions {
	_options.IssueType = core.StringPtr(issueType)
	return _options
}

// SetIssueID : Allow user to set IssueID
func (_options *DeleteExemptionResourceOptions) SetIssueID(issueID string) *DeleteExemptionResourceOptions {
	_options.IssueID = core.StringPtr(issueID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *DeleteExemptionResourceOptions) SetHeaders(param map[string]string) *DeleteExemptionResourceOptions {
	options.Headers = param
	return options
}

// ExemptHandlerOptions : The ExemptHandler options.
type ExemptHandlerOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewExemptHandlerOptions : Instantiate ExemptHandlerOptions
func (*VulnerabilityAdvisorV4) NewExemptHandlerOptions() *ExemptHandlerOptions {
	return &ExemptHandlerOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ExemptHandlerOptions) SetHeaders(param map[string]string) *ExemptHandlerOptions {
	options.Headers = param
	return options
}

// Exemption : Exemption struct
type Exemption struct {
	// The unique ID for the IBM Cloud account for this policy.
	AccountID *string `json:"account_id" validate:"required"`

	// ID of issue being exempted.
	IssueID *string `json:"issue_id" validate:"required"`

	// Type of issue being exempted.
	IssueType *string `json:"issue_type" validate:"required"`

	Scope *ExemptionScope `json:"scope,omitempty"`
}

// UnmarshalExemption unmarshals an instance of Exemption from the specified map of raw messages.
func UnmarshalExemption(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Exemption)
	err = core.UnmarshalPrimitive(m, "account_id", &obj.AccountID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "issue_id", &obj.IssueID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "issue_type", &obj.IssueType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "scope", &obj.Scope, UnmarshalExemptionScope)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ExemptionScope : ExemptionScope struct
type ExemptionScope struct {
	// The type of scope the exemption applies to: account, namespace, repository, image.
	ScopeType *string `json:"scope_type" validate:"required"`

	// The IBM Cloud Registry namespace included in scope.
	Namespace *string `json:"namespace,omitempty"`

	// The IBM Cloud Registry repository included in scope.
	Repository *string `json:"repository,omitempty"`

	// The IBM Cloud Registry tag included in scope.
	Tag *string `json:"tag,omitempty"`
}

// UnmarshalExemptionScope unmarshals an instance of ExemptionScope from the specified map of raw messages.
func UnmarshalExemptionScope(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ExemptionScope)
	err = core.UnmarshalPrimitive(m, "scope_type", &obj.ScopeType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "namespace", &obj.Namespace)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "repository", &obj.Repository)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tag", &obj.Tag)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ExemptionsAccountDeleteHandlerOptions : The ExemptionsAccountDeleteHandler options.
type ExemptionsAccountDeleteHandlerOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewExemptionsAccountDeleteHandlerOptions : Instantiate ExemptionsAccountDeleteHandlerOptions
func (*VulnerabilityAdvisorV4) NewExemptionsAccountDeleteHandlerOptions() *ExemptionsAccountDeleteHandlerOptions {
	return &ExemptionsAccountDeleteHandlerOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ExemptionsAccountDeleteHandlerOptions) SetHeaders(param map[string]string) *ExemptionsAccountDeleteHandlerOptions {
	options.Headers = param
	return options
}

// GetExemptionAccountOptions : The GetExemptionAccount options.
type GetExemptionAccountOptions struct {
	// Exemption type, e.g. 'cve' or 'sn' or 'configuration'. See /va/api/v4/exempt/types for more details.
	IssueType *string `json:"issueType" validate:"required,ne="`

	// Exemption ID, e.g. 'CVE-2018-9999'. See /va/api/v4/exempt/types for more details.
	IssueID *string `json:"issueID" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetExemptionAccountOptions : Instantiate GetExemptionAccountOptions
func (*VulnerabilityAdvisorV4) NewGetExemptionAccountOptions(issueType string, issueID string) *GetExemptionAccountOptions {
	return &GetExemptionAccountOptions{
		IssueType: core.StringPtr(issueType),
		IssueID: core.StringPtr(issueID),
	}
}

// SetIssueType : Allow user to set IssueType
func (_options *GetExemptionAccountOptions) SetIssueType(issueType string) *GetExemptionAccountOptions {
	_options.IssueType = core.StringPtr(issueType)
	return _options
}

// SetIssueID : Allow user to set IssueID
func (_options *GetExemptionAccountOptions) SetIssueID(issueID string) *GetExemptionAccountOptions {
	_options.IssueID = core.StringPtr(issueID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetExemptionAccountOptions) SetHeaders(param map[string]string) *GetExemptionAccountOptions {
	options.Headers = param
	return options
}

// GetExemptionResourceOptions : The GetExemptionResource options.
type GetExemptionResourceOptions struct {
	// IBM Cloud Registry resource (namespace, namespace/repository, namespace/repository:tag, or
	// namespace/repository@sha256:hash).
	Resource *string `json:"resource" validate:"required,ne="`

	// Exemption type, e.g. 'cve' or 'sn' or 'configuration'. See /va/api/v4/exempt/types for more details.
	IssueType *string `json:"issueType" validate:"required,ne="`

	// Exemption ID, e.g. 'CVE-2018-9999'. See /va/api/v4/exempt/types for more details.
	IssueID *string `json:"issueID" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewGetExemptionResourceOptions : Instantiate GetExemptionResourceOptions
func (*VulnerabilityAdvisorV4) NewGetExemptionResourceOptions(resource string, issueType string, issueID string) *GetExemptionResourceOptions {
	return &GetExemptionResourceOptions{
		Resource: core.StringPtr(resource),
		IssueType: core.StringPtr(issueType),
		IssueID: core.StringPtr(issueID),
	}
}

// SetResource : Allow user to set Resource
func (_options *GetExemptionResourceOptions) SetResource(resource string) *GetExemptionResourceOptions {
	_options.Resource = core.StringPtr(resource)
	return _options
}

// SetIssueType : Allow user to set IssueType
func (_options *GetExemptionResourceOptions) SetIssueType(issueType string) *GetExemptionResourceOptions {
	_options.IssueType = core.StringPtr(issueType)
	return _options
}

// SetIssueID : Allow user to set IssueID
func (_options *GetExemptionResourceOptions) SetIssueID(issueID string) *GetExemptionResourceOptions {
	_options.IssueID = core.StringPtr(issueID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *GetExemptionResourceOptions) SetHeaders(param map[string]string) *GetExemptionResourceOptions {
	options.Headers = param
	return options
}

// ImageReportQueryPathOptions : The ImageReportQueryPath options.
type ImageReportQueryPathOptions struct {
	// The name of the image. For example, us.icr.io/namespace/repository:tag.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewImageReportQueryPathOptions : Instantiate ImageReportQueryPathOptions
func (*VulnerabilityAdvisorV4) NewImageReportQueryPathOptions(name string) *ImageReportQueryPathOptions {
	return &ImageReportQueryPathOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *ImageReportQueryPathOptions) SetName(name string) *ImageReportQueryPathOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ImageReportQueryPathOptions) SetHeaders(param map[string]string) *ImageReportQueryPathOptions {
	options.Headers = param
	return options
}

// ImageStatusQueryPathOptions : The ImageStatusQueryPath options.
type ImageStatusQueryPathOptions struct {
	// The name of the image. For example, us.icr.io/namespace/repository:tag.
	Name *string `json:"name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewImageStatusQueryPathOptions : Instantiate ImageStatusQueryPathOptions
func (*VulnerabilityAdvisorV4) NewImageStatusQueryPathOptions(name string) *ImageStatusQueryPathOptions {
	return &ImageStatusQueryPathOptions{
		Name: core.StringPtr(name),
	}
}

// SetName : Allow user to set Name
func (_options *ImageStatusQueryPathOptions) SetName(name string) *ImageStatusQueryPathOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ImageStatusQueryPathOptions) SetHeaders(param map[string]string) *ImageStatusQueryPathOptions {
	options.Headers = param
	return options
}

// ListAccountExemptionsOptions : The ListAccountExemptions options.
type ListAccountExemptionsOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListAccountExemptionsOptions : Instantiate ListAccountExemptionsOptions
func (*VulnerabilityAdvisorV4) NewListAccountExemptionsOptions() *ListAccountExemptionsOptions {
	return &ListAccountExemptionsOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListAccountExemptionsOptions) SetHeaders(param map[string]string) *ListAccountExemptionsOptions {
	options.Headers = param
	return options
}

// ListBulkImageExemptionsOptions : The ListBulkImageExemptions options.
type ListBulkImageExemptionsOptions struct {
	// List of images.
	Body []string `json:"body" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListBulkImageExemptionsOptions : Instantiate ListBulkImageExemptionsOptions
func (*VulnerabilityAdvisorV4) NewListBulkImageExemptionsOptions(body []string) *ListBulkImageExemptionsOptions {
	return &ListBulkImageExemptionsOptions{
		Body: body,
	}
}

// SetBody : Allow user to set Body
func (_options *ListBulkImageExemptionsOptions) SetBody(body []string) *ListBulkImageExemptionsOptions {
	_options.Body = body
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListBulkImageExemptionsOptions) SetHeaders(param map[string]string) *ListBulkImageExemptionsOptions {
	options.Headers = param
	return options
}

// ListExemptionAccountOptions : The ListExemptionAccount options.
type ListExemptionAccountOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListExemptionAccountOptions : Instantiate ListExemptionAccountOptions
func (*VulnerabilityAdvisorV4) NewListExemptionAccountOptions() *ListExemptionAccountOptions {
	return &ListExemptionAccountOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ListExemptionAccountOptions) SetHeaders(param map[string]string) *ListExemptionAccountOptions {
	options.Headers = param
	return options
}

// ListExemptionResourceOptions : The ListExemptionResource options.
type ListExemptionResourceOptions struct {
	// IBM Cloud Registry resource (namespace, namespace/repository, namespace/repository:tag, or
	// namespace/repository@sha256:hash).
	Resource *string `json:"resource" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListExemptionResourceOptions : Instantiate ListExemptionResourceOptions
func (*VulnerabilityAdvisorV4) NewListExemptionResourceOptions(resource string) *ListExemptionResourceOptions {
	return &ListExemptionResourceOptions{
		Resource: core.StringPtr(resource),
	}
}

// SetResource : Allow user to set Resource
func (_options *ListExemptionResourceOptions) SetResource(resource string) *ListExemptionResourceOptions {
	_options.Resource = core.StringPtr(resource)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListExemptionResourceOptions) SetHeaders(param map[string]string) *ListExemptionResourceOptions {
	options.Headers = param
	return options
}

// ListImageExemptionsOptions : The ListImageExemptions options.
type ListImageExemptionsOptions struct {
	// IBM Cloud Registry resource (namespace, namespace/repository, namespace/repository:tag, or
	// namespace/repository@sha256:hash).
	Resource *string `json:"resource" validate:"required,ne="`

	// Include scope on returned exemptions.
	IncludeScope *bool `json:"includeScope,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewListImageExemptionsOptions : Instantiate ListImageExemptionsOptions
func (*VulnerabilityAdvisorV4) NewListImageExemptionsOptions(resource string) *ListImageExemptionsOptions {
	return &ListImageExemptionsOptions{
		Resource: core.StringPtr(resource),
	}
}

// SetResource : Allow user to set Resource
func (_options *ListImageExemptionsOptions) SetResource(resource string) *ListImageExemptionsOptions {
	_options.Resource = core.StringPtr(resource)
	return _options
}

// SetIncludeScope : Allow user to set IncludeScope
func (_options *ListImageExemptionsOptions) SetIncludeScope(includeScope bool) *ListImageExemptionsOptions {
	_options.IncludeScope = core.BoolPtr(includeScope)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ListImageExemptionsOptions) SetHeaders(param map[string]string) *ListImageExemptionsOptions {
	options.Headers = param
	return options
}

// ScanReport : ScanReport struct
type ScanReport struct {
	// Not supported, will always be empty.
	ConfigurationIssues []ScanresultConfigurationIssue `json:"configuration_issues" validate:"required"`

	// The unique ID of the report.
	ID *string `json:"id" validate:"required"`

	// The primary operating system distribution identified in the container image.
	OsDistribution *ScanReportOsDistribution `json:"os_distribution" validate:"required"`

	// The last time that the vulnerability data source was checked for vulnerabilities as a UNIX timestamp.
	ScanTime *int64 `json:"scan_time" validate:"required"`

	// Overall vulnerability assessment status: OK, WARN, FAIL, UNSUPPORTED, INCOMPLETE, UNSCANNED. For more information
	// about these status codes, see
	// https://{DomainName}/apidocs/container-registry/va#getting-started-vulnerability-report-status-codes.
	Status *string `json:"status" validate:"required"`

	// The detailed vulnerability assessment status for each scan engine
	StatusDetail *StatusDetail `json:"status_detail" validate:"required"`

	// Vulnerabilities found in the container image at the scan time.
	Vulnerabilities []ScanresultCVE `json:"vulnerabilities" validate:"required"`
}

// UnmarshalScanReport unmarshals an instance of ScanReport from the specified map of raw messages.
func UnmarshalScanReport(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ScanReport)
	err = core.UnmarshalModel(m, "configuration_issues", &obj.ConfigurationIssues, UnmarshalScanresultConfigurationIssue)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "os_distribution", &obj.OsDistribution, UnmarshalScanReportOsDistribution)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "scan_time", &obj.ScanTime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vulnerabilities", &obj.Vulnerabilities, UnmarshalScanresultCVE)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status_detail", &obj.StatusDetail, UnmarshalStatusDetail)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

type StatusDetail struct {
	IBMVA       *ScanStatusDetail `json:"ibm_va,omitempty"`
	PrismaCloud *ScanStatusDetail `json:"prisma_cloud,omitempty"`
}

// UnmarshalScanReportList unmarshals an instance of ScanReportList from the specified map of raw messages.
func UnmarshalStatusDetail(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StatusDetail)
	err = core.UnmarshalModel(m, "ibm_va", &obj.IBMVA, UnmarshalScanStatusDetail)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "prisma_cloud", &obj.PrismaCloud, UnmarshalScanStatusDetail)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

type ScanStatusDetail struct {
	ScanUUID   *string `json:"scan_uuid"`
	ScanTime   *int    `json:"scan_time"`
	StatusCode *int    `json:"status_code"`
	Status     *string `json:"status"`
	Message    *string `json:"message,omitempty"`
	ErrorCode  *string `json:"error_code,omitempty"`
}

// UnmarshalScanresultConfigurationIssue unmarshals an instance of ScanresultConfigurationIssue from the specified map of raw messages.
func UnmarshalScanStatusDetail(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ScanStatusDetail)
	err = core.UnmarshalPrimitive(m, "scan_uuid", &obj.ScanUUID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "scan_time", &obj.ScanTime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status_code", &obj.StatusCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "error_code", &obj.ErrorCode)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ScanReportList : ScanReportList struct
type ScanReportList struct {
	// A dictionary of image names as key and report.Report object as value.
	Assessments map[string]ScanReport `json:"assessments" validate:"required"`
}

// UnmarshalScanReportList unmarshals an instance of ScanReportList from the specified map of raw messages.
func UnmarshalScanReportList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ScanReportList)
	err = core.UnmarshalModel(m, "assessments", &obj.Assessments, UnmarshalScanReport)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ScanReportOsDistribution : The primary operating system distribution identified in the container image.
type ScanReportOsDistribution struct {
	// Primary operating system distribution.
	DistributionID *string `json:"distribution_id,omitempty"`

	// Primary operating system version.
	VersionID *string `json:"version_id,omitempty"`

	// Primary operating system version code name.
	VersionCodeName *string `json:"version_code_name,omitempty"`
}

// UnmarshalScanReportOsDistribution unmarshals an instance of ScanReportOsDistribution from the specified map of raw messages.
func UnmarshalScanReportOsDistribution(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ScanReportOsDistribution)
	err = core.UnmarshalPrimitive(m, "distribution_id", &obj.DistributionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version_id", &obj.VersionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version_code_name", &obj.VersionCodeName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ExemptionDeletionInfo : ExemptionDeletionInfo struct
type ExemptionDeletionInfo struct {
	NumberOfExemptionsDeleted *int64 `json:"number_of_exemptions_deleted" validate:"required"`
}

// UnmarshalExemptionDeletionInfo unmarshals an instance of ExemptionDeletionInfo from the specified map of raw messages.
func UnmarshalExemptionDeletionInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ExemptionDeletionInfo)
	err = core.UnmarshalPrimitive(m, "number_of_exemptions_deleted", &obj.NumberOfExemptionsDeleted)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ExemptionTypeInfo : ExemptionTypeInfo struct
type ExemptionTypeInfo struct {
	DisplayName *string `json:"display_name" validate:"required"`

	Identifier *string `json:"identifier" validate:"required"`

	TranslationKey *string `json:"translationKey,omitempty"`

	ValidationRegex *string `json:"validation_regex" validate:"required"`
}

// UnmarshalExemptionTypeInfo unmarshals an instance of ExemptionTypeInfo from the specified map of raw messages.
func UnmarshalExemptionTypeInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ExemptionTypeInfo)
	err = core.UnmarshalPrimitive(m, "display_name", &obj.DisplayName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "identifier", &obj.Identifier)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "translationKey", &obj.TranslationKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "validation_regex", &obj.ValidationRegex)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ScanreportImageSummary : ScanreportImageSummary struct
type ScanreportImageSummary struct {
	// Not supported, this will always be zero.
	ConfigurationIssueCount *int64 `json:"configuration_issue_count" validate:"required"`

	// The image creation time as a UNIX timestamp.
	CreatedTime *int64 `json:"created_time" validate:"required"`

	// Not supported, this will always be zero.
	ExemptConfigurationIssueCount *int64 `json:"exempt_configuration_issue_count" validate:"required"`

	// The number of exempt issues found.
	ExemptIssueCount *int64 `json:"exempt_issue_count" validate:"required"`

	// The number of exempt vulnerability issues found.
	ExemptVulnerabilityCount *int64 `json:"exempt_vulnerability_count" validate:"required"`

	// The number of issues found.
	IssueCount *int64 `json:"issue_count" validate:"required"`

	// Full docker image name including tag e.g. us.icr.io/namespace/repository:tag.
	Name *string `json:"name" validate:"required"`

	// The last time that the vulnerability data source was checked for vulnerabilities as a UNIX timestamp.
	ScanTime *int64 `json:"scan_time" validate:"required"`

	// Overall vulnerability assessment status: OK, WARN, FAIL, UNSUPPORTED, INCOMPLETE, UNSCANNED. For more information
	// about these status codes, see
	// https://{DomainName}/apidocs/container-registry/va#getting-started-vulnerability-report-status-codes.
	Status *string `json:"status" validate:"required"`

	// The number of vulnerability issues found.
	VulnerabilityCount *int64 `json:"vulnerability_count" validate:"required"`
}

// UnmarshalScanreportImageSummary unmarshals an instance of ScanreportImageSummary from the specified map of raw messages.
func UnmarshalScanreportImageSummary(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ScanreportImageSummary)
	err = core.UnmarshalPrimitive(m, "configuration_issue_count", &obj.ConfigurationIssueCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created_time", &obj.CreatedTime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "exempt_configuration_issue_count", &obj.ExemptConfigurationIssueCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "exempt_issue_count", &obj.ExemptIssueCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "exempt_vulnerability_count", &obj.ExemptVulnerabilityCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "issue_count", &obj.IssueCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "scan_time", &obj.ScanTime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vulnerability_count", &obj.VulnerabilityCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ScanreportImageSummaryList : ScanreportImageSummaryList struct
type ScanreportImageSummaryList struct {
	// List of image summaries.
	Images []ScanreportImageSummary `json:"images" validate:"required"`
}

// UnmarshalScanreportImageSummaryList unmarshals an instance of ScanreportImageSummaryList from the specified map of raw messages.
func UnmarshalScanreportImageSummaryList(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ScanreportImageSummaryList)
	err = core.UnmarshalModel(m, "images", &obj.Images, UnmarshalScanreportImageSummary)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ScanreportSummary : ScanreportSummary struct
type ScanreportSummary struct {
	// Not supported, this will always be zero.
	ConfigurationIssueCount *int64 `json:"configuration_issue_count" validate:"required"`

	// Not supported, this will always be zero.
	ExemptConfigurationIssueCount *int64 `json:"exempt_configuration_issue_count" validate:"required"`

	// The number of exempt issues found.
	ExemptIssueCount *int64 `json:"exempt_issue_count" validate:"required"`

	// The number of exempt vulnerability issues found.
	ExemptVulnerabilityCount *int64 `json:"exempt_vulnerability_count" validate:"required"`

	// The number of issues found.
	IssueCount *int64 `json:"issue_count" validate:"required"`

	// The last time that the vulnerability data source was checked for vulnerabilities as a UNIX timestamp.
	ScanTime *int64 `json:"scan_time" validate:"required"`

	// Overall vulnerability assessment status: OK, WARN, FAIL, UNSUPPORTED, INCOMPLETE, UNSCANNED. For more information
	// about these status codes, see
	// https://{DomainName}/apidocs/container-registry/va#getting-started-vulnerability-report-status-codes.
	Status *string `json:"status" validate:"required"`

	// The number of vulnerability issues found.
	VulnerabilityCount *int64 `json:"vulnerability_count" validate:"required"`
}

// UnmarshalScanreportSummary unmarshals an instance of ScanreportSummary from the specified map of raw messages.
func UnmarshalScanreportSummary(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ScanreportSummary)
	err = core.UnmarshalPrimitive(m, "configuration_issue_count", &obj.ConfigurationIssueCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "exempt_configuration_issue_count", &obj.ExemptConfigurationIssueCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "exempt_issue_count", &obj.ExemptIssueCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "exempt_vulnerability_count", &obj.ExemptVulnerabilityCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "issue_count", &obj.IssueCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "scan_time", &obj.ScanTime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vulnerability_count", &obj.VulnerabilityCount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ScanresultCVE : ScanresultCVE struct
type ScanresultCVE struct {
	// True if this CVE has been exempted by user policy, and false otherwise.
	CveExempt *bool `json:"cve_exempt" validate:"required"`

	// The ID for this CVE.
	CveID *string `json:"cve_id" validate:"required"`

	// Number of security notices that contain fixes for this CVE and are exempted by user policy.
	ExemptSecurityNoticeCount *int64 `json:"exempt_security_notice_count" validate:"required"`

	// 'exempt' if this CVE is exempt or all security notices for this CVE are exempt. 'partial' if this CVE is not exempt
	// but a subset of security notices for this CVE are exempt. 'active' if this CVE is not exempt and no security notices
	// for this CVE are exempt.
	ExemptStatus *string `json:"exempt_status" validate:"required"`

	// Number of security notices that contain fixes for this CVE and are not exempted by user policy.
	SecurityNoticeCount *int64 `json:"security_notice_count" validate:"required"`

	// Security notices that contain fixes for this CVE.
	SecurityNotices []ScanresultSecurityNotice `json:"security_notices" validate:"required"`

	// The summary of the security vulnerability for this CVE.
	Summary *string `json:"summary" validate:"required"`

	// Total number of security notices that contain fixes for this CVE.
	TotalSecurityNoticeCount *int64 `json:"total_security_notice_count" validate:"required"`

	// The scan engine(s) that detected the CVE
	ScanEngines []string `json:"scan_engines" validate:"required"`
}

// UnmarshalScanresultCVE unmarshals an instance of ScanresultCVE from the specified map of raw messages.
func UnmarshalScanresultCVE(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ScanresultCVE)
	err = core.UnmarshalPrimitive(m, "cve_exempt", &obj.CveExempt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cve_id", &obj.CveID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "exempt_security_notice_count", &obj.ExemptSecurityNoticeCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "exempt_status", &obj.ExemptStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "security_notice_count", &obj.SecurityNoticeCount)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "security_notices", &obj.SecurityNotices, UnmarshalScanresultSecurityNotice)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "summary", &obj.Summary)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total_security_notice_count", &obj.TotalSecurityNoticeCount)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "scan_engines", &obj.ScanEngines)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ScanresultConfigurationIssue : ScanresultConfigurationIssue struct
type ScanresultConfigurationIssue struct {
	// Not supported.
	CorrectiveAction *string `json:"corrective_action" validate:"required"`

	// Not supported.
	Description *string `json:"description" validate:"required"`

	// Not supported.
	Exempt *bool `json:"exempt" validate:"required"`

	// Not supported.
	Meta map[string]string `json:"meta" validate:"required"`

	// Not supported.
	Type *string `json:"type" validate:"required"`

	// The scan engine(s) that detected the configuration issue
	ScanEngines []string `json:"scan_engines" validate:"required"`
}

// UnmarshalScanresultConfigurationIssue unmarshals an instance of ScanresultConfigurationIssue from the specified map of raw messages.
func UnmarshalScanresultConfigurationIssue(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ScanresultConfigurationIssue)
	err = core.UnmarshalPrimitive(m, "corrective_action", &obj.CorrectiveAction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "exempt", &obj.Exempt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "meta", &obj.Meta)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ScanresultPackageFixes : ScanresultPackageFixes struct
type ScanresultPackageFixes struct {
	// Advice on how to solve this vulnerability.
	CorrectiveAction *string `json:"corrective_action" validate:"required"`

	// Description of the vulnerability.
	Description *string `json:"description" validate:"required"`

	// The version of this package that contains the fix for this vulnerability.
	FixVersion *string `json:"fix_version" validate:"required"`

	// The version of this package that was found installed at scan time.
	InstalledVersion *string `json:"installed_version" validate:"required"`

	// The name of the package.
	PackageName *string `json:"package_name" validate:"required"`
}

// UnmarshalScanresultPackageFixes unmarshals an instance of ScanresultPackageFixes from the specified map of raw messages.
func UnmarshalScanresultPackageFixes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ScanresultPackageFixes)
	err = core.UnmarshalPrimitive(m, "corrective_action", &obj.CorrectiveAction)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "fix_version", &obj.FixVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "installed_version", &obj.InstalledVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "package_name", &obj.PackageName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ScanresultSecurityNotice : ScanresultSecurityNotice struct
type ScanresultSecurityNotice struct {
	// Further information about this security notice.
	Notice *string `json:"notice" validate:"required"`

	// True if this security notice has been exempted by user policy, and false otherwise.
	NoticeExempt *bool `json:"notice_exempt" validate:"required"`

	// The ID for this security notice.
	NoticeID *string `json:"notice_id" validate:"required"`

	// Summary of information about the security vulnerabilities fixed by this security notice.
	Summary *string `json:"summary" validate:"required"`

	// Package updates that contain fixes for this vulnerability.
	VulnerablePackages []ScanresultPackageFixes `json:"vulnerable_packages" validate:"required"`

	// The scan engine(s) that detected the security notice
	ScanEngines []string `json:"scan_engines" validate:"required"`

	// The reference of the security notice
	References []string `json:"references"`
}

// UnmarshalScanresultSecurityNotice unmarshals an instance of ScanresultSecurityNotice from the specified map of raw messages.
func UnmarshalScanresultSecurityNotice(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ScanresultSecurityNotice)
	err = core.UnmarshalPrimitive(m, "notice", &obj.Notice)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "notice_exempt", &obj.NoticeExempt)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "notice_id", &obj.NoticeID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "summary", &obj.Summary)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vulnerable_packages", &obj.VulnerablePackages, UnmarshalScanresultPackageFixes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "scan_engines", &obj.ScanEngines)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "references", &obj.References)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}
